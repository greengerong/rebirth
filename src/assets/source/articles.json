{
  "result": [
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美(Page 1)",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/test/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "Zone.js - 暴力之美",
      "date": "2016-01-30 21:27:00",
      "comments": true,
      "categories": [
        "angular2",
        "javascript"
      ],
      "markdownPath": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.markdown",
      "markdown": "\n在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（[thread-local storage: 线程本地存储](http://en.wikipedia.org/wiki/Thread-local_storage)）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。\n\n那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？\n\n#### 问题引入\n\n我们先来看一段常规的同步JavaScript代码：\n\n\tvar foo = function(){ ... },\n\t\tbar = function(){ ... },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -> bar -> baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。\n\n\tvar start, \n\t\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\t\n\tstart = timer();\n\n\tfoo(); \n\tbar(); \n\tbaz(); \n\t\n\tconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n\n但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：[JavaScript单线程和浏览器事件循环简述](http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/)。\n\n那么对于下面这段异步代码，我们又如何做性能监测呢？\n\n\tvar foo = function(){ setTimeout(..., 2000); },\n\t\tbar = function(){ $.get(...).success(...); },\n\t\tbaz = function(){ ... };\n\n\tfoo();\n\tbar();\n\tbaz();\n\n\n在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。\n\n#### zone.js简介\n\n在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：\n\n* \tonZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；\n*\tbeforeTask：zone Task执行前的钩子函数；\n*\tafterTask：zone Task执行完成后的钩子函数；\n*\tonError：zone运行Task时候的异常钩子函数；\n\n并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：\n\n*\tzone.alert;\n*\tzone.prompt;\n*\tzone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;\n*\tzone.addEventListener;\n*\tzone.addEventListener、zone.removeEventListener;\n*\tzone.setTimeout、zone.clearTimeout、zone.setImmediate;\n*\tzone.setInterval、zone.clearInterval\n\n以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们[https://github.com/angular/zone.js/tree/master/lib/patch](https://github.com/angular/zone.js/tree/master/lib/patch)。\n\n\n下面我们先来看一个简单的zone.js示例：\n\n\tvar log = function(phase){\n\t\treturn function(){\n\t\t\tconsole.log(\"I am in zone.js \" + phase + \"!\");\n\t\t};\n\t};\n\n\tzone.fork({\n\t\tonZoneCreated: log(\"onZoneCreated\"),\n\t\tbeforeTask: log(\"beforeTask\"),\n\t\tafterTask: log(\"afterTask\"),\n\t}).run(function(){\n\t\tvar methodLog = function(func){\n\t\t\treturn function(){\n\t\t\t\tconsole.log(\"I am from \" + func + \" function!\");\n\t\t\t};\n\t\t},\n\t\tfoo = methodLog(\"foo\"),\n\t\tbar = methodLog(\"bar\"),\n\t\tbaz = function(){\n\t\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t\t};\n\t\t\n\t\tfoo();\n\t\tbaz();\n\t\tbar();\n\t});\n\n执行这段示例代码的输出是：\n\n\tI am in zone.js beforeTask!\n\tI am from foo function!\n\tI am from bar function!\n\tI am in zone.js afterTask!\n\n\tI am in zone.js onZoneCreated!\n\tI am in zone.js beforeTask!\n\tI am from baz in setTimeout function!\n\tI am in zone.js afterTask!\n\n从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。\n\n在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。\n\n同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。\n\n*\t$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；\n*\t-代表在父zone的钩子函数之前运行本钩子函数；\n*\t+则与之相反，代表在父zone的钩子函数之后运行本钩子函数\n\n更多的语法使用，请参考zone.js github首页文档[https://github.com/angular/zone.js](https://github.com/angular/zone.js)。\n\n#### 引入zone.js\n\n有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：[https://github.com/angular/zone.js/blob/master/example/profiling.html](https://github.com/angular/zone.js/blob/master/example/profiling.html)\n\n\tvar profilingZone = (function () {\n\t    var time = 0,\n\t        timer = performance ?\n\t                    performance.now.bind(performance) :\n\t                    Date.now.bind(Date);\n\t    return {\n\t      beforeTask: function () {\n\t        this.start = timer();\n\t      },\n\t      afterTask: function () {\n\t        time += timer() - this.start;\n\t      },\n\t      time: function () {\n\t        return Math.floor(time*100) / 100 + 'ms';\n\t      },\n\t      reset: function () {\n\t        time = 0;\n\t      }\n\t    };\n\t  }());\n\n\t  zone.fork(profilingZone).run(function(){\n\n\t  \t //业务逻辑代码\n\n\t  });\n\n这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。\n\n#### zone.js的实现\n\n了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？\n\n下面是zone.js中browser.ts的代码片段（[https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts](https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts)）：\n\n\texport function apply() {\n\t  fnPatch.patchSetClearFunction(global, global.Zone, [\n\t    ['setTimeout', 'clearTimeout', false, false],\n\t    ['setInterval', 'clearInterval', true, false],\n\t    ['setImmediate', 'clearImmediate', false, false],\n\t    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n\t    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n\t    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n\t  ]);\n\n\t  fnPatch.patchFunction(global, [\n\t    'alert',\n\t    'prompt'\n\t  ]);\n\n\t  eventTargetPatch.apply();\n\n\t  propertyDescriptorPatch.apply();\n\n\t  promisePatch.apply();\n\n\t  mutationObserverPatch.patchClass('MutationObserver');\n\t  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n\t  definePropertyPatch.apply();\n\n\t  registerElementPatch.apply();\n\n\t  geolocationPatch.apply();\n\n\t  fileReaderPatch.apply();\n\t}\n\n从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（[https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts](https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts)）的代码片段：\n\n\texport function patchSetClearFunction(window, Zone, fnNames) {\n\t  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n\t    //浏览器原生方法留存\n\t    var setNative = window[setName];\n    \tvar clearNative = window[clearName];\n    \tvar ids = {};\n\n\t    if (setNative) {\n\t      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\t      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n\t      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[setName] = function () {\n\t        return global.zone[setName].apply(global.zone, arguments);\n\t      };\n\n\t      // 对浏览器原生方法的包裹封装\n\t      window[clearName] = function () {\n\t        return global.zone[clearName].apply(global.zone, arguments);\n\t      };\n\n\n\t      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n\t      Zone.prototype[setName] = function (fn, delay) {\n\t        \n\t        var callbackFn = fn;\n\t        if (typeof callbackFn !== 'function') {\n\t          // force the error by calling the method with wrong args\n\t          setNative.apply(window, arguments);\n\t        }\n\t        var zone = this;\n\t        var setId = null;\n\t        // wrap the callback function into the zone.\n\t        arguments[0] = function() {\n\t          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n\t          var callbackThis = this;\n\t          var callbackArgs = arguments;\n\t          return wtf.leaveScope(\n\t              wtfCallbackFn(callbackZone.$id, setId, delay),\n\t              callbackZone.run(function() {\n\t                if (!repeating) {\n\t                  delete ids[setId];\n\t                  callbackZone.removeTask(callbackFn);\n\t                }\n\t                return callbackFn.apply(callbackThis, callbackArgs);\n\t              })\n\t          );\n\t        };\n\t        if (repeating) {\n\t          zone.addRepeatingTask(callbackFn);\n\t        } else {\n\t          zone.addTask(callbackFn);\n\t        }\n\t        setId = setNative.apply(window, arguments);\n\t        ids[setId] = callbackFn;\n\t        wtfSetEventFn(zone.$id, setId, delay);\n\t        return setId;\n\t      };\n\t      ......\n\t     \n\t    }\n\t  }\n\t  fnNames.forEach(function(args) {\n\t    patchMacroTaskMethod.apply(null, args);\n\t  });\n\t};\n\n在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。\n\n到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。\n\n#### zone.js应用场景\n\nzone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在[https://github.com/angular/zone.js/tree/master/example](https://github.com/angular/zone.js/tree/master/example)看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: [https://www.youtube.com/watch?v=3IqtmUscE_U](https://www.youtube.com/watch?v=3IqtmUscE_U).\n\n当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。\n\n也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。\n\n当然，zone.js也能应用于Angular1的项目之中。示例代码如下（[http://jsbin.com/kenilivuvi/edit?html,js,output](http://jsbin.com/kenilivuvi/edit?html,js,output)）：\n\n\tangular.module(\"com.ngbook.demo\", [])\n\t    .controller(\"DemoController\", ['$scope', function($scope){\n\t     \n\t\t\tzone.fork({\n\t\t\t\tafterTask: function(){\n\t\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n\t    \t\t\t\t$scope.$apply();\n\t   \t\t\t\t }\n\t  \t\t\t}\n\t\t\t}).run(function(){\n\t\t\t\t\n\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t$scope.fromZone = \"I am from zone with setTimeout!\";\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t\t\n\t\t}]);\n\n\n在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（[https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts](https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts)）。\n ",
      "path": "/2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "url": "2016-01-30-zone-dot-js-bao-li-zhi-mei.html",
      "html": "<p>在ng2的开发过程中，Angular团队为我们带来了一个新的库 - zone.js。zone.js的设计灵感来源于Dart语言，它描述JavaScript执行过程的上下文，可以在异步任务之间进行持久性传递，它类似于Java中的TLS（<a href=\"http://en.wikipedia.org/wiki/Thread-local_storage\">thread-local storage: 线程本地存储</a>）技术，zone.js则是将TLS引入到JavaScript语言中的实现框架。</p>\n<p>那么zone.js能为我们解决什么问题呢？在回答这个问题之前，博主更希望回顾下在JavaScript开发中，我们究竟遇见了什么难题？</p>\n<h4>问题引入</h4>\n<p>我们先来看一段常规的同步JavaScript代码：</p>\n<pre><code>var foo = function(){ ... },\n\tbar = function(){ ... },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>这段代码并没有什么特殊之处，它的执行顺序也并无什么特殊之处，完全在我们的预知之内：foo -&gt; bar -&gt; baz。对它做性能监测也很容易，我们只需要在执行上下文前后记录执行时间即可。</p>\n<pre><code>var start, \n\ttimer = performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\nstart = timer();\n\nfoo(); \nbar(); \nbaz(); \n\nconsole.log(Math.floor((timer() - start) * 100) / 100 + 'ms');\n</code></pre>\n<p>但在JavaScript的世界并不全是这么简单，众所周知的JavaScript单线程执行的。因此为了不阻塞UI界面的用户体验，在JavaScript执行的很多耗时操作都被封装为了异步操作，如：setTimeout、XMLHttpRequest、DOM事件等。由于浏览器的寄宿限制，JavaScript中异步操作是与生俱来的特性，被深深的印在了骨髓之中。这也是Ryan Dahl博士选择JavaScript开发Node.js平台的原因之一。关于JavaScript单线程执行可以参考博主的另一篇博文：<a href=\"http://greengerong.com/blog/2015/10/27/javascript-single-thread-and-browser-event-loop/\">JavaScript单线程和浏览器事件循环简述</a>。</p>\n<p>那么对于下面这段异步代码，我们又如何做性能监测呢？</p>\n<pre><code>var foo = function(){ setTimeout(..., 2000); },\n\tbar = function(){ $.get(...).success(...); },\n\tbaz = function(){ ... };\n\nfoo();\nbar();\nbaz();\n</code></pre>\n<p>在这段代码中，引入了setTimeout和AJAX异步调用。其中AJAX回调和setTimeout回调时间顺序很难确定，因此给这段代码引入性能检测代码并不像上面的顺序执行代码一样那么简单了。如果我们需要强行加入性能的检测，则会在setTimeout和$.get回调中插入相关的hook代码并并记录执行时间，这样我们的业务代码也会变得非常混乱，就像一团“意大利拉面”一样（What the fuck！）。</p>\n<h4>zone.js简介</h4>\n<p>在本文开篇提到zone.js为JavaScript提供了执行上下文，可以在异步任务之间进行持久性传递。该是zone.js上场的时候了。zone.js采用猴子补丁（Monkey-patched）的暴力方式将JavaScript中的异步任务都包裹了一层，使得这些异步任务都将运行在zone的上下文中。每一个异步的任务在zone.js都被当做为一个Task，并在Task的基础上zone.js为开发者提供了执行前后的钩子函数（hook）。这些钩子函数包括：</p>\n<ul>\n<li>onZoneCreated：产生一个新的zone对象时的钩子函数。zone.fork也会产生一个继承至基类zone的新zone，形成一个独立的zone上下文；</li>\n<li>beforeTask：zone Task执行前的钩子函数；</li>\n<li>afterTask：zone Task执行完成后的钩子函数；</li>\n<li>onError：zone运行Task时候的异常钩子函数；</li>\n</ul>\n<p>并且zone.js对JavaScript中的大多数异步事件都做了包裹封装，它们包括：</p>\n<ul>\n<li>zone.alert;</li>\n<li>zone.prompt;</li>\n<li>zone.requestAnimationFrame、zone.webkitRequestAnimationFrame、zone.mozRequestAnimationFrame;</li>\n<li>zone.addEventListener;</li>\n<li>zone.addEventListener、zone.removeEventListener;</li>\n<li>zone.setTimeout、zone.clearTimeout、zone.setImmediate;</li>\n<li>zone.setInterval、zone.clearInterval</li>\n</ul>\n<p>以及对promise、geolocation定位信息、websocket等也进行了包裹封装，你可以在这里找到它们<a href=\"https://github.com/angular/zone.js/tree/master/lib/patch\">https://github.com/angular/zone.js/tree/master/lib/patch</a>。</p>\n<p>下面我们先来看一个简单的zone.js示例：</p>\n<pre><code>var log = function(phase){\n\treturn function(){\n\t\tconsole.log(&quot;I am in zone.js &quot; + phase + &quot;!&quot;);\n\t};\n};\n\nzone.fork({\n\tonZoneCreated: log(&quot;onZoneCreated&quot;),\n\tbeforeTask: log(&quot;beforeTask&quot;),\n\tafterTask: log(&quot;afterTask&quot;),\n}).run(function(){\n\tvar methodLog = function(func){\n\t\treturn function(){\n\t\t\tconsole.log(&quot;I am from &quot; + func + &quot; function!&quot;);\n\t\t};\n\t},\n\tfoo = methodLog(&quot;foo&quot;),\n\tbar = methodLog(&quot;bar&quot;),\n\tbaz = function(){\n\t\tsetTimeout(methodLog('baz in setTimeout'), 0);\n\t};\n\t\n\tfoo();\n\tbaz();\n\tbar();\n});\n</code></pre>\n<p>执行这段示例代码的输出是：</p>\n<pre><code>I am in zone.js beforeTask!\nI am from foo function!\nI am from bar function!\nI am in zone.js afterTask!\n\nI am in zone.js onZoneCreated!\nI am in zone.js beforeTask!\nI am from baz in setTimeout function!\nI am in zone.js afterTask!\n</code></pre>\n<p>从上面的输出结果，我们能够看出在zone.js中将run方法块分为了两个Task，它们分别是方法体运行时的Task和异步setTimeout的Task。并且我们能够在这些Task的创建，执行前后拦截并做一些有意义的事情。</p>\n<p>在zone.js中fork方法会产生一个继承至zone的子类，并在fork函数中可以配置特定的钩子方法，形成独立的zone上下文。而run方法则是启动执行业务代码的对外接口。</p>\n<p>同时zone也支持父子继承，以及它也定义了一套DSL语法，支持$、+、-的前缀。</p>\n<ul>\n<li>$会传递父类zone的钩子函数，便于对zone钩子函数执行的控制；</li>\n<li>-代表在父zone的钩子函数之前运行本钩子函数；</li>\n<li>+则与之相反，代表在父zone的钩子函数之后运行本钩子函数</li>\n</ul>\n<p>更多的语法使用，请参考zone.js github首页文档<a href=\"https://github.com/angular/zone.js\">https://github.com/angular/zone.js</a>。</p>\n<h4>引入zone.js</h4>\n<p>有了上面的这些关于zone.js的基础知识，在本文开始的遗留问题我们就可以迎刃而解了。下面这段代码是来自zone.js项目的示例代码：<a href=\"https://github.com/angular/zone.js/blob/master/example/profiling.html\">https://github.com/angular/zone.js/blob/master/example/profiling.html</a></p>\n<pre><code>var profilingZone = (function () {\n    var time = 0,\n        timer = performance ?\n                    performance.now.bind(performance) :\n                    Date.now.bind(Date);\n    return {\n      beforeTask: function () {\n        this.start = timer();\n      },\n      afterTask: function () {\n        time += timer() - this.start;\n      },\n      time: function () {\n        return Math.floor(time*100) / 100 + 'ms';\n      },\n      reset: function () {\n        time = 0;\n      }\n    };\n  }());\n\n  zone.fork(profilingZone).run(function(){\n\n  \t //业务逻辑代码\n\n  });\n</code></pre>\n<p>这里在beforeTask中启动了时间计算，并在afterTask中计算出当前累积的花费的时间。因此我们在业务代码的逻辑中就可以随时利用zone.time()来获取当前耗时了。</p>\n<h4>zone.js的实现</h4>\n<p>了解了zone.js的时候之后，或许你会像我一样感觉很神奇，它是如何实现的呢？</p>\n<p>下面是zone.js中browser.ts的代码片段（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/browser.ts</a>）：</p>\n<pre><code>export function apply() {\n  fnPatch.patchSetClearFunction(global, global.Zone, [\n    ['setTimeout', 'clearTimeout', false, false],\n    ['setInterval', 'clearInterval', true, false],\n    ['setImmediate', 'clearImmediate', false, false],\n    ['requestAnimationFrame', 'cancelAnimationFrame', false, true],\n    ['mozRequestAnimationFrame', 'mozCancelAnimationFrame', false, true],\n    ['webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', false, true]\n  ]);\n\n  fnPatch.patchFunction(global, [\n    'alert',\n    'prompt'\n  ]);\n\n  eventTargetPatch.apply();\n\n  propertyDescriptorPatch.apply();\n\n  promisePatch.apply();\n\n  mutationObserverPatch.patchClass('MutationObserver');\n  mutationObserverPatch.patchClass('WebKitMutationObserver');\n\n  definePropertyPatch.apply();\n\n  registerElementPatch.apply();\n\n  geolocationPatch.apply();\n\n  fileReaderPatch.apply();\n}\n</code></pre>\n<p>从这里我们能看到，zone.js对浏览器中的setTimeout、setInterval、setImmediate、以及事件、promise、地理信息geolocation都做了特殊处理。那么这些处理是怎么处理的呢？下面是关于fnPatch.patchSetClearFunction的实现代码，来自zone.js中functions.ts（<a href=\"https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts\">https://github.com/angular/zone.js/blob/master/lib/patch/functions.ts</a>）的代码片段：</p>\n<pre><code>export function patchSetClearFunction(window, Zone, fnNames) {\n  function patchMacroTaskMethod(setName, clearName, repeating, isRaf) {\n    //浏览器原生方法留存\n    var setNative = window[setName];\n\tvar clearNative = window[clearName];\n\tvar ids = {};\n\n    if (setNative) {\n      var wtfSetEventFn = wtf.createEvent('Zone#' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n      var wtfClearEventFn = wtf.createEvent('Zone#' + clearName + '(uint32 zone, uint32 id)');\n      var wtfCallbackFn = wtf.createScope('Zone#cb:' + setName + '(uint32 zone, uint32 id, uint32 delay)');\n\n      // 对浏览器原生方法的包裹封装\n      window[setName] = function () {\n        return global.zone[setName].apply(global.zone, arguments);\n      };\n\n      // 对浏览器原生方法的包裹封装\n      window[clearName] = function () {\n        return global.zone[clearName].apply(global.zone, arguments);\n      };\n\n\n      // 创建自己包裹方法，由上面的wind[setName]转移到这里执行.\n      Zone.prototype[setName] = function (fn, delay) {\n        \n        var callbackFn = fn;\n        if (typeof callbackFn !== 'function') {\n          // force the error by calling the method with wrong args\n          setNative.apply(window, arguments);\n        }\n        var zone = this;\n        var setId = null;\n        // wrap the callback function into the zone.\n        arguments[0] = function() {\n          var callbackZone = zone.isRootZone() || isRaf ? zone : zone.fork();\n          var callbackThis = this;\n          var callbackArgs = arguments;\n          return wtf.leaveScope(\n              wtfCallbackFn(callbackZone.$id, setId, delay),\n              callbackZone.run(function() {\n                if (!repeating) {\n                  delete ids[setId];\n                  callbackZone.removeTask(callbackFn);\n                }\n                return callbackFn.apply(callbackThis, callbackArgs);\n              })\n          );\n        };\n        if (repeating) {\n          zone.addRepeatingTask(callbackFn);\n        } else {\n          zone.addTask(callbackFn);\n        }\n        setId = setNative.apply(window, arguments);\n        ids[setId] = callbackFn;\n        wtfSetEventFn(zone.$id, setId, delay);\n        return setId;\n      };\n      ......\n     \n    }\n  }\n  fnNames.forEach(function(args) {\n    patchMacroTaskMethod.apply(null, args);\n  });\n};\n</code></pre>\n<p>在上面的代码中，首先会将浏览器的原生方法保存在setNative中以便将会重用。紧接着zone.js就开始了它的暴力行为，覆盖window[setName]和window[clearName]然后将对setName的调用转到自身的zone[setName]的调用，zone.js就是如此暴力的对浏览器原生对象实现了拦截转移。然后它会在Task执行的前后调用自身的addRepeatingTask、addTask以及wtf事件来应用注册上的所有钩子函数。</p>\n<p>到这里相信作为读者的你已经明白了zone.js的实现机制了，是不是和笔者一样有种“简单粗暴”的感觉？但是它真的很强大，为我们实现了对异步Task的跟踪、分析等。</p>\n<h4>zone.js应用场景</h4>\n<p>zone.js能实现异步Task跟踪，分析，错误记录、开发调试跟踪等，这些都是zone.js场景的应用场景。你也可以在<a href=\"https://github.com/angular/zone.js/tree/master/example\">https://github.com/angular/zone.js/tree/master/example</a>看见更多的示例代码，以及Brian在ng-conf 2014关于zone.js的演讲视频: <a href=\"https://www.youtube.com/watch?v=3IqtmUscE_U\">https://www.youtube.com/watch?v=3IqtmUscE_U</a>.</p>\n<p>当然对于一些特定的业务分析zone.js也有它很好的运用场景。如果你使用过Angular1的开发，那么也许你还能记忆犹新的想起：使用第三方事件或者ajax却忘记$scope.$apply的场景吧。在Angular1中如果在非Angular的上下文改变数据Model，Angular是无法预知的，因此也不会触发界面的更新。所以我们不得不显示的调用$scope.$apply或者$timeout来触发界面的更新。Angular框架为了更多的获知变化的事件，不得不为封装了一整套框架内置的服务和指令，如ngClick、ngChange、$http,$timeout等，这也增加了Angular1的学习成本。</p>\n<p>也是为了解决Angular1的这一些列问题，Angular2团队引入了zone.js，放弃自定义这类服务和指令，相反而是拥抱浏览器的原生对象和方法。所以在Angular2中可以使用浏览器的任何事件了，只需要括号模板语法的标识：(eventName),等价于on-eventName；也可以直接使用浏览器的原生对象了，如setTimeout，addEventListener、promise、fetch等。</p>\n<p>当然，zone.js也能应用于Angular1的项目之中。示例代码如下（<a href=\"http://jsbin.com/kenilivuvi/edit?html,js,output\">http://jsbin.com/kenilivuvi/edit?html,js,output</a>）：</p>\n<pre><code>angular.module(&quot;com.ngbook.demo&quot;, [])\n    .controller(&quot;DemoController&quot;, ['$scope', function($scope){\n     \n\t\tzone.fork({\n\t\t\tafterTask: function(){\n\t\t\t\tvar phase = $scope.$root.$$phase;\n\t\t\t\tif(['$apply', '$digest'].indexOf(phase) === -1) {\n    \t\t\t\t$scope.$apply();\n   \t\t\t\t }\n  \t\t\t}\n\t\t}).run(function(){\n\t\t\t\n\t\t\tsetTimeout(function(){\n\t\t\t\t$scope.fromZone = &quot;I am from zone with setTimeout!&quot;;\n\t\t\t}, 2000);\n\t\t});\n\t\t\n\t}]);\n</code></pre>\n<p>在示例代码中，在每次Task的完成后都会尝试$scope.$apply，强制将Model数据的改变更新到UI界面。对于在Angular1中使用zone.js更多的地方应该是在Directive中，同时也可以将zone的创建过程封装为服务（工厂方法，每次返回一个全新的zone对象）。在Angular2中也有同样zone的封装，它被称为ngZone（<a href=\"https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts\">https://github.com/angular/angular/blob/master/modules/angular2/src/core/zone/ng_zone.ts</a>）。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    },
    {
      "layout": "post",
      "title": "《AngularJS深度剖析与最佳实践》简介 last one",
      "date": "2015-12-30 15:29:27",
      "comments": true,
      "categories": [
        "Angular",
        "javascript",
        "书籍"
      ],
      "markdownPath": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.markdown",
      "markdown": "\n由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。\n\n\n在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。\n\n[![http://item.jd.com/11845736.html](http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg)](http://item.jd.com/11845736.html)\n\n链接地址：[http://item.jd.com/11845736.html](http://item.jd.com/11845736.html)\n\n### 双狼的写作感谢\n\n我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。\n\n还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。\n\n还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：\n\t\n\t冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n　　\n还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！\n\n### 书籍的阅读指南\n\nAngular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。\n\n本书的主体结构也是针对这样的学习曲线设计的：\n\n#### 首先，初级阶段，轻松入门\n\n我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。\n\n#### 然后，中级阶段，概念介绍\n\n在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。\n\n#### 接下来，高级阶段，工作原理\n\n学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。\n\n#### 最后，专家阶段：最佳实践，技巧\n\n前面主要是入门和理论，而这部分将主要以实战经验为主。\n\n只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。\n\n专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。\n\n#### 坑\n\n在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。\n\n#### 工具\n\n工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。\n\n#### 更多\n\n在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。\n\nHybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。\n\n#### 附录\n\n软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。\n\n#### 关于随书代码\n\n书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。\n\n如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。\n\n另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。\n\n\n\n",
      "path": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "url": "2015-12-30-angularjsshen-du-pou-xi-yu-zui-jia-shi-jian-jian-jie.html",
      "html": "<p>由于年末将至，前阵子一直忙于工作的事务，不得已暂停了微信订阅号的更新，我将会在后续的时间里尽快的继续为大家推送更多的博文。毕竟一个人的力量微薄，精力有限，希望大家能理解，仍然能一如既往的关注和支持shuang_lang_shuo[破狼]微信号，同时也欢迎大家的高质量文章的投稿。</p>\n<p>在2015年一年时间中，我、雪狼大叔、彭洪伟一起共同编写了《AngularJS深度剖析与最佳实践》这本前端Angular.js框架的进阶书籍。在写作期间也得到很多人的支持，特别是在Angularjs中文社区群中的各位群友的持续关注。中途由于写作、出版流程等因素，花费了大家很长的等待时间，就在昨天《AngularJS深度剖析与最佳实践》这本书籍终于上市了，大家现在可以在京东上预订书籍了，相信出版社也会在很快的时间内送到大家手中。</p>\n<p><a href=\"http://item.jd.com/11845736.html\"><img src=\"http://img11.360buyimg.com/n1/jfs/t2164/170/1927361173/116828/d85d9ddf/5680e85dNdd2009df.jpg\" alt=\"http://item.jd.com/11845736.html\"></a></p>\n<p>链接地址：<a href=\"http://item.jd.com/11845736.html\">http://item.jd.com/11845736.html</a></p>\n<h3>双狼的写作感谢</h3>\n<p>我和雪狼的本次合作起于机械工业出版社编辑吴怡的邀请。作为ThoughtWorks的Tech Lead，双狼都有很多工作任务，原定6个月的写书计划，被拖到了8个月，感谢吴怡的耐心等待与支持。</p>\n<p>还有很多ThoughtWorker为本书做出了贡献：\n　　\n\t张逸，资深ThoughtWorker，很多技术书籍的作者或译者。一直在鼓励我们，并给了我们很多帮助。\n\t彭洪伟，本书的第三作者。在交稿压力最大的时候，承担了“工具”篇的撰写工作，保障了本书的尽早交稿。\n\t陈嘉，幕后的贡献者，全栈式工程师。帮我们设计了“双狼说”微信公众号的Logo，从技术的角度帮我们审稿，并提了一些非常有用的建议。</p>\n<p>还有很多ThoughtWorker和社区朋友帮助我们从技术层面和语言层面进行修改。他们有的是Angular专家，有的是新手，给了我们比较全面的反馈。能将枯燥、乏味的技术平易近人地展现在这本书中，一定要感谢他们所作出的奉献。他们是（排名不分先后）：</p>\n<pre><code>冯尔东、朱本威、李科伟、杨琛、彭琰、叶志敏、ng群as。\n</code></pre>\n<p>还要感谢Angular中文社区QQ群和关注“双狼说”微信号的网友们，是你们的鼓励给了我们写作的信心和动力！</p>\n<h3>书籍的阅读指南</h3>\n<p>Angular的学习曲线大概是这样的：入门非常容易，中级的时候会发现需要深入理解很多概念，高级的时候需要掌握Angular的工作原理，而想成为专家则很难，需要经过很多工程实践的磨练。</p>\n<p>本书的主体结构也是针对这样的学习曲线设计的：</p>\n<h4>首先，初级阶段，轻松入门</h4>\n<p>我们会带你在实战中逐步体验Angular的开发过程，并随着进度的推进，逐步引入所需的技术和概念。</p>\n<h4>然后，中级阶段，概念介绍</h4>\n<p>在实战中提到的一些概念不会就地展开，而是只做简介，到了这里，会对概念进行深入讲解：是什么，为什么，怎么用，什么时候用，什么时候不用等。</p>\n<h4>接下来，高级阶段，工作原理</h4>\n<p>学习了这些概念，我们还要把它们串起来，向读者揭示Angular的工作原理，看看这些概念之间是如何协作的。</p>\n<h4>最后，专家阶段：最佳实践，技巧</h4>\n<p>前面主要是入门和理论，而这部分将主要以实战经验为主。</p>\n<p>只把Angular用熟了是不够的，我们还要把它整合进更宏观的开发过程中，不但要考虑开发，更要考虑维护。我们要如何开发容易维护的Angular程序？请看“最佳实践”一节。</p>\n<p>专家还需要掌握一些技巧去把复杂问题简单化，把一些不常用但很有用的API发掘出来，把看起来平淡无奇的框架特性运用得出神入化，“使用技巧”一节将集中展现这一点。</p>\n<h4>坑</h4>\n<p>在前面的章节中零零散散提到了一些需要注意的地方，但是这样不方便查阅，所以我们把它作为独立的一大章，把我们帮别人解决过的一些典型问题收集在一起。\n当然，我们也会在读者社区继续维护并更新这些“坑”，而不是等再版时才发布。\n我们希望能把这本书做成“活的”，让这本书更加物超所值，不辜负读者对我们的信任。</p>\n<h4>工具</h4>\n<p>工欲善其事，必先利其器。充分发挥工具的力量是开发人员的重要素质，日常用到的工具你真的用熟了吗？有没有更好地工具？我们会把实战中觉得对自己帮助最大的工具及其使用经验分享给你。</p>\n<h4>更多</h4>\n<p>在实战中，有很多需求是不显眼但很重要的，比如SEO、访问统计等，在实际的项目中，这些往往是不能忽视的。\n我们会专门开一章来讲解如何结合Angular和第三方软件来干净漂亮的解决这些问题。</p>\n<p>Hybrid应用和手机Web越来越普及，手机版开发的需求也越来越高，在Angular的基础上，开发手机版变得容易多了。而且，也已经有了比较成熟的工具和框架，我们会简要讲解一下手机版开发的方法和框架。</p>\n<h4>附录</h4>\n<p>软件开发需要很多综合技能，但本书容量有限，我们也不可能是每个领域的专家。因此，我们会“授人以渔”，给出一些在线资源和书单，供大家深入学习或作为备查资料。</p>\n<h4>关于随书代码</h4>\n<p>书中所摘录的只是全部代码的一小部分，大部分代码都放在了Github上。</p>\n<p>如果你查看Git历史，会发现总的提交数并不多。这是因为要方便教学，所以在提交前进行了合并。所保留的这些提交大都和书中的主要进度有关，略去了细节提交。所以，本书中代码的提交粒度不能代表实际项目中的提交粒度，在实际项目中，其提交粒度通常比本书中所示范的更小。阅读代码时请记住这一点，以免养成“大粒度提交”的坏习惯。</p>\n<p>另外，文中的js代码（包括摘引的angular源码）全都使用了两格缩进模式，这主要是考虑到图书排版问题，希望少一些不必要的换行。你们在现实项目中愿意用两格或四格均可，只要项目组内保持一致。</p>\n"
    }
  ]
}
